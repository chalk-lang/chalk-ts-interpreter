/*/
  Grammar of the Chalk language.
  
  If you change the grammar, also change the hardcoded number of states of the
  parser table in `parser-table-generator.ts`. Ctrl + F `numOfStates`.
/*/

import * as Rules from "./chalk-ir";

export type Rule = [string, string[]];

export type Grammar = Rule[];

export function isTerminal(symbol: string): boolean {
  return !symbol.match(/^[A-Z]/);
}

export const startSymbols = [ "ChalkModule", "ChalkDocModule" ];

export const chalkGrammar: Grammar =
  [ [ "ChalkModule", [ "Imports", "DefExprs" ] ],
    [ "Imports", [ "Import", "Imports" ] ],
    [ "Imports", [] ],
    [ "Import", [ "import", "ImportWhat", "lIdentifier", "string", ";" ] ],
    [ "ImportWhat", [ "uIdentifier" ] ],
    [ "ImportWhat", [ "ObjectLit" ] ],
    [ "DefExprs", [ "DefExpr", "DefExprs" ] ],
    [ "DefExprs", [ "Proposition", ";", "DefExprs" ]],
    [ "DefExprs", [] ],
    [ "DefExprsTrait", [ "DefExpr", "DefExprsTrait" ] ],
    [ "DefExprsTrait", [ "Proposition", ";", "DefExprsTrait" ] ],
    [ "DefExprsTrait", [ "FnDeclaration", ";", "DefExprsTrait" ] ],
    [ "DefExprsTrait", [] ],
    [ "DefExpr", [ "VarDef", ";" ] ],
    [ "DefExpr", [ "ArrowFnDef", ";" ] ],
    [ "DefExpr", [ "FnDef" ] ],
    [ "DefExpr", [ "ClassDef" ] ],
    [ "DefExpr", [ "TraitDef" ] ],
    [ "VarDef", [ "VarDefSkeleton", "=", "Expr" ] ],
    [ "VarDef", [ "VarDefSkeleton", "Tuple" ] ],
    [ "VarDef", [ "AtomicType", "Tuple" ] ],
    [ "VarDef", [ "Access", "AtomicType", "Tuple" ] ],
    [ "VarDefSkeleton", [ "Type", "Identifier" ] ],
    [ "VarDefSkeleton", [ "Access", "Type", "Identifier" ] ],
    [ "VarDefSkeleton", [ "Access", "Identifier" ] ],
    [ "Identifier", [ "lIdentifier" ] ],
    [ "Identifier", [ "uIdentifier" ] ],
    [ "Access", [ "mut" ] ],
    [ "Access", [ "let" ] ],
    [ "Access", [ "cst" ] ],
    [ "Access", [ "imt" ] ],
    [ "ArrowFnDef", [ "MType", "Identifier", "=>", "Expr" ] ],
    [ "ArrowFnDef", [ "MType", "MIdentifier", "(", "IdList", ")", "=>", "Expr" ] ],
    [ "ArrowFnDef", [ "MType", "MIdentifier", "(", "Params", ")", "=>", "Expr" ] ],
    [ "FnDeclaration", [ "MType", "lIdentifier", "(", "Params", ")" ] ],
    [ "FnDef", [ "FnDeclaration", "BlockOrEmpty" ] ],
    [ "MType", [ "Type" ] ],
    [ "MType", [] ],
    [ "MIdentifier", [ "Identifier" ] ],
    [ "MIdentifier", [] ],
    [ "IdList", [ "Identifier", "IdListNext" ] ],
    [ "IdList", [] ],
    [ "IdListNext", [ ",", "Identifier", "IdListNext" ] ],
    [ "IdListNext", [] ],
    [ "Params", [ "Type", "Identifier", "ParamsRest" ] ],
    [ "Params", [] ],
    [ "ParamsRest", [ ",", "Type", "Identifier" ] ],
    [ "ParamsRest", [ ",", "Identifier" ] ],
    [ "ParamsRest", [ "," ] ],
    [ "ParamsRest", [] ],
    [ "ClassDef", [ "class", "uIdentifier", "GenericParams", "{", "DefExprs", "}" ] ],
    [ "TraitDef", [ "trait", "uIdentifier", "GenericParams", "{", "DefExprsTrait", "}" ] ],
    [ "GenericParams", [ "<", "Params", ">" ] ],
    [ "GenericParams", [] ],
    [ "Type", [ "TypeUnion" ] ],
    [ "TypeUnion", [ "TypeIntersection", "|", "TypeUnion" ] ],
    [ "TypeUnion", [ "TypeIntersection" ] ],
    [ "TypeIntersection", [ "AtomicType", "&", "TypeIntersection" ] ],
    [ "TypeIntersection", [ "AtomicType" ] ],
    [ "AtomicType", [ "TypeModifier", "AtomicType" ] ],
    [ "AtomicType", [ "class" ] ],
    [ "AtomicType", [ "trait" ] ],
    [ "AtomicType", [ "type" ] ],
    [ "AtomicType", [ "any" ] ],
    [ "AtomicType", [ "(", "Type", "TypeListNext", ")" ] ],
    [ "AtomicType", [ "MemAccessType" ] ],
    [ "TypeModifier", [ "[]" ] ],
    [ "TypeModifier", [ "*" ] ],
    [ "MemAccessType", [ "Identifier", ".", "MemAccessType" ] ],
    [ "MemAccessType", [ "uIdentifier" ] ],
    [ "MemAccessType", [ "uIdentifier", "<", "Type", "TypeListNext", ">" ] ],
    [ "TypeListNext", [ ",", "Type", "TypeListNext" ] ],
    [ "TypeListNext", [] ],
    [ "Expr", [ "ExprS", "Expr" ] ],
    [ "Expr", [ "ExprS", "Expr" ] ],
    [ "Expr", [ "ExprS", "Expr" ] ],
    [ "Expr", [ "ExprS", "Expr" ] ],
    [ "Expr", [ "ExprS", "Expr" ] ],
    [ "Expr", [ "ExprS", "Expr" ] ],
    [ "Expr", [ "ExprS", "Expr" ] ],
    [ "Expr", [ "continue" ] ],
    [ "Expr", [ "QMarkR" ] ],
    [ "ExprS", [ "return" ] ],
    [ "ExprS", [ "break" ] ],
    [ "ExprS", [ "comptime" ] ],
    [ "ExprS", [ "ignore" ] ],
    [ "ExprS", [ "mutab" ] ],
    [ "ExprS", [ "immut" ] ],
    [ "ExprS", [ "const" ] ],
    [ "QMarkR", [ "OrL", "?", "Expr", ":", "QMarkR" ] ],
    [ "QMarkR", [ "OrR" ] ],
    [ "QMarkL", [ "OrL", "?", "Expr", ":", "QMarkL" ] ],
    [ "QMarkL", [ "OrL" ] ],
    [ "OrR", [ "AndL", "||", "OrR" ] ],
    [ "OrR", [ "AndR" ] ],
    [ "OrL", [ "AndL", "||", "OrL" ] ],
    [ "OrL", [ "AndL" ] ],
    [ "AndR", [ "EqualL", "&&", "AndR" ] ],
    [ "AndR", [ "EqualR" ] ],
    [ "AndL", [ "EqualL", "&&", "AndL" ] ],
    [ "AndL", [ "EqualL" ] ],
    [ "EqualR", [ "EqualL", "EqualS", "RelationR" ] ],
    [ "EqualR", [ "EqualL", "EqualS", "RelationR" ] ],
    [ "EqualR", [ "RelationR" ] ],
    [ "EqualL", [ "EqualL", "EqualS", "RelationL" ] ],
    [ "EqualL", [ "EqualL", "EqualS", "RelationL" ] ],
    [ "EqualL", [ "RelationL" ] ],
    [ "EqualS", [ "==" ] ],
    [ "EqualS", [ "!=" ] ],
    [ "RelationR", [ "CompareL", "<", "CompareR" ] ],
    [ "RelationR", [ "CompareL", ">", "CompareR" ] ],
    [ "RelationR", [ "CompareL", "<=", "CompareR" ] ],
    [ "RelationR", [ "CompareL", ">=", "CompareR" ] ],
    [ "RelationR", [ "CompareL", "is", "CompareR" ] ],
    [ "RelationR", [ "CompareR" ] ],
    [ "RelationL", [ "CompareL", "<", "CompareL" ] ],
    [ "RelationL", [ "CompareL", ">", "CompareL" ] ],
    [ "RelationL", [ "CompareL", "<=", "CompareL" ] ],
    [ "RelationL", [ "CompareL", ">=", "CompareL" ] ],
    [ "RelationL", [ "CompareL", "is", "CompareL" ] ],
    [ "RelationL", [ "CompareL" ] ],
    [ "RelationS", [ "<" ] ],
    [ "RelationS", [ ">" ] ],
    [ "RelationS", [ "<=" ] ],
    [ "RelationS", [ ">=" ] ],
    [ "RelationS", [ "is" ] ],
    [ "CompareR", [ "ConcatL", "<=>", "ConcatR" ] ],
    [ "CompareR", [ "ConcatR" ] ],
    [ "CompareL", [ "ConcatL", "<=>", "ConcatL" ] ],
    [ "CompareL", [ "ConcatL" ] ],
    [ "ConcatR", [ "ConcatL", "++", "ModR" ] ],
    [ "ConcatR", [ "ModR" ] ],
    [ "ConcatL", [ "ConcatL", "++", "ModL" ] ],
    [ "ConcatL", [ "ModL" ] ],
    [ "ModR", [ "ModL", "%", "AddR" ] ],
    [ "ModR", [ "AddR" ] ],
    [ "ModL", [ "ModL", "%", "AddL" ] ],
    [ "ModL", [ "AddL" ] ],
    [ "AddR", [ "AddL", "AddS", "MulR" ] ],
    [ "AddR", [ "AddL", "AddS", "MulR" ] ],
    [ "AddR", [ "MulR" ] ],
    [ "AddL", [ "AddL", "AddS", "MulL" ] ],
    [ "AddL", [ "AddL", "AddS", "MulL" ] ],
    [ "AddL", [ "MulL" ] ],
    [ "AddS", [ "+" ] ],
    [ "AddS", [ "-" ] ],
    [ "MulR", [ "MulL", "MulS", "PowR" ] ],
    [ "MulR", [ "MulL", "MulS", "PowR" ] ],
    [ "MulR", [ "PowR" ] ],
    [ "MulL", [ "MulL", "MulS", "PowL" ] ],
    [ "MulL", [ "MulL", "MulS", "PowL" ] ],
    [ "MulL", [ "PowL" ] ],
    [ "MulS", [ "*" ] ],
    [ "MulS", [ "/" ] ],
    [ "PowR", [ "Neg", "**", "PowR" ] ],
    [ "PowR", [ "Neg" ] ],
    [ "PowR", [ "Assign" ] ],
    [ "PowL", [ "Neg", "**", "PowL" ] ],
    [ "PowL", [ "Neg" ] ],
    [ "Assign", [ "Neg", "AssignS", "Expr" ] ],
    [ "Assign", [ "Neg", "AssignS", "Expr" ] ],
    [ "Assign", [ "Neg", "AssignS", "Expr" ] ],
    [ "Assign", [ "Neg", "AssignS", "Expr" ] ],
    [ "Assign", [ "Neg", "AssignS", "Expr" ] ],
    [ "Assign", [ "Neg", "AssignS", "Expr" ] ],
    [ "Assign", [ "Neg", "AssignS", "Expr" ] ],
    [ "AssignS", [ "=" ] ],
    [ "AssignS", [ "+=" ] ],
    [ "AssignS", [ "-=" ] ],
    [ "AssignS", [ "*=" ] ],
    [ "AssignS", [ "/=" ] ],
    [ "AssignS", [ "%=" ] ],
    [ "AssignS", [ "**=" ] ],
    [ "Neg", [ "!", "Neg" ] ],
    [ "Neg", [ "NegS", "Neg" ] ],
    [ "Neg", [ "Unary" ] ],
    [ "NegS", [ "await" ] ],
    [ "NegS", [ "nowait" ] ],
    [ "NegS", [ "ignore" ] ],
    [ "Unary", [ "Unary", ".", "lIdentifier" ] ],
    [ "Unary", [ "Unary", "[", "Expr", "]" ] ],
    [ "Unary", [ "lIdentifier" ] ],
    [ "Unary", [ "Type" ] ],
    [ "Unary", [ "Literal" ] ],
    [ "Unary", [ "FunctionCall" ] ],
    [ "Unary", [ "Block" ] ],
    [ "Unary", [ "Switch" ] ],
    [ "Unary", [ "For" ] ],
    [ "Literal", [ "number" ] ],
    [ "Literal", [ "string" ] ],
    [ "Literal", [ "VarDef" ] ],
    [ "Literal", [ "ArrowFnDef" ] ],
    [ "Literal", [ "FnDef" ] ],
    [ "Literal", [ "ClassDef" ] ],
    [ "Literal", [ "TraitDef" ] ],
    [ "Literal", [ "Array" ] ],
    [ "Literal", [ "Tuple" ] ],
    [ "Literal", [ "ObjectLit" ] ],
    [ "Literal", [ "SetLit" ] ],
    [ "Array", [ "[", "]" ] ],
    [ "Array", [ "[", "Expr", "LitExprListNext", "]" ] ],
    [ "Array", [ "[", "VarDefSkeleton", "LitExprListNext", "]" ] ],
    [ "Tuple", [ "(", ")" ] ],
    [ "Tuple", [ "(", "Expr", "LitExprListNext", ")" ] ],
    [ "Tuple", [ "(", "VarDefSkeleton", "LitExprListNext", ")" ] ],
    [ "ObjectLit", [ "{", "}" ] ],
    [ "ObjectLit", [ "{", "Identifier", "ObjNext", "}" ] ],
    [ "ObjectLit", [ "{", "Identifier", ":", "Expr", "ObjNext", "}" ] ],
    [ "ObjectLit", [ "{", "Identifier", ":", "VarDefSkeleton", "ObjNext", "}" ] ],
    [ "ObjectLit", [ "{", "VarDefSkeleton", "ObjNext", "}" ] ],
    [ "ObjectLit", [ "{", "VarDef", "ObjNext", "}" ] ],
    [ "ObjNext", [ ",", "Identifier", "ObjNext" ] ],
    [ "ObjNext", [ ",", "Identifier", ":", "Expr", "ObjNext" ] ],
    [ "ObjNext", [ ",", "Identifier", ":", "VarDefSkeleton", "ObjNext" ] ],
    [ "ObjNext", [ ",", "VarDefSkeleton", "ObjNext" ] ],
    [ "ObjNext", [ ",", "VarDef", "ObjNext" ] ],
    [ "ObjNext", [] ],
    [ "SetLit", [ "{", "Expr", ",", "Expr", "SetNext", "}" ] ],
    [ "SetLit", [ "{", "Expr", ",", "VarDefSkeleton", "SetNext", "}" ] ],
    [ "SetLit", [ "{", "VarDefSkeleton", ",", "Expr", "SetNext", "}" ] ],
    [ "SetLit", [ "{", "VarDefSkeleton", ",", "VarDefSkeleton", "SetNext", "}" ] ],
    [ "SetNext", [ ",", "Expr", "SetNext" ] ],
    [ "SetNext", [ ",", "VarDefSkeleton", "SetNext" ] ],
    [ "SetNext", [] ],
    [ "LitExprListNext", [ ",", "Expr", "LitExprListNext" ] ],
    [ "LitExprListNext", [ ",", "VarDefSkeleton", "LitExprListNext" ] ],
    [ "LitExprListNext", [] ],
    [ "FunctionCall", [ "Expr", "Tuple" ] ],
    [ "Block", [ "{", "ExprList", "}" ] ],
    [ "ExprList", [ "Expr" ] ],
    [ "ExprList", [ "Expr", ";" ] ],
    [ "ExprList", [ "Proposition" ] ],
    [ "ExprList", [ "DefExpr" ] ],
    [ "ExprList", [ "Expr", ";", "ExprList" ] ],
    [ "ExprList", [ "Proposition", "ExprList" ] ],
    [ "ExprList", [ "DefExpr", "ExprList" ] ],
    [ "BlockOrEmpty", [ "{", "}" ] ],
    [ "BlockOrEmpty", [ "Block" ] ],
    [ "Switch", [ "switch", "MExpr", "{", "Cases", "}" ] ], // Here 0
    [ "MExpr", [ "Expr" ] ],
    [ "MExpr", [] ],
    [ "Cases", [ "Case", "Cases" ] ],
    [ "Cases", [ "Case" ] ],
    [ "Case", [ "case", "Expr", ":", "Expr", ";" ] ],
    [ "Case", [ "case", "Expr", ":", "DefExpr" ] ],
    [ "Case", [ "default", ":", "Expr" ] ],
    [ "Case", [ "default", ":", "DefExpr" ] ],
    [ "For", [ "for", "BlockOrEmpty" ] ],
    [ "For", [ "for", "Expr", ";", "BlockOrEmpty" ] ],
    [ "For", [ "for", "Expr", ";", "Expr", ";", "BlockOrEmpty" ] ],
    [ "For", [ "for", "Expr", ";", "Expr", ";", "Expr", ";", "BlockOrEmpty" ] ],
    
    [ "Proposition", [ "Proposition" ] ],
    /*
    [ "Proposition", [ "@All", ":", "Stm" ] ],
    [ "Proposition", [ "@All", "Relation", ":", "Stm" ] ],
    [ "Proposition", [ "@All", "StmDef", ":", "Stm" ] ],
    [ "Proposition", [ "@Exists", "Relation", ":", "Stm" ] ],
    [ "Proposition", [ "@Exists", "StmDef", ":", "Stm" ] ],
    [ "Proposition", [ "@Ex", "Relation", ":", "Stm" ] ],
    [ "Proposition", [ "@Ex", "StmDef", ":", "Stm" ] ],
    [ "Stm", [ "Proposition" ] ],
    [ "Stm", [ "Relation" ] ],
    [ "Stm", [ "Stm", "<-", "Stm" ] ],
    [ "Stm", [ "Stm", "->", "Stm" ] ],
    [ "Stm", [ "Stm", "<->", "Stm" ] ],
    [ "Relation", [ "hmm" ] ], // TODO
    [ "StmDef", [ "hmm" ] ], // TODO
    
    
    
    
    [ "Plaintext", [ "string" ] ],
    [ "JSON", [] ], // TODO
    [ "ChalkDoc", [] ], // TODO
    
    [ "ChalkDocModule", [] ],
    */
  ];

function checkGrammarCorrectenss(grammar: Grammar) {
  for (let rule of grammar) {
    if (!(Rules as any)[rule[0]]) {
      throw new Error("Rule " + rule[0] + " doesn't have its corresponding class.");
    }
    
    for (let symbol of rule[1]) {
      if (!isTerminal(symbol) && !grammar.find(rule => rule[0] == symbol)) {
        throw new Error("Undefined non-terminal: " + symbol);
      }
    }
  }
}

checkGrammarCorrectenss(chalkGrammar);
